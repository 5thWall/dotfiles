" Plugins yo!
set nocompatible
filetype plugin indent on
let mapleader = "<Space>"

"" matchit
runtime macros/matchit.vim

"" powerline fonts
let g:airline_powerline_fonts = 1

"" pathogen
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect()

" COLORS! WOOOO!
syntax on
set background=dark
" set background=light
let g:solarized_hitrail=1
set cursorline
set cursorcolumn
set incsearch
set hlsearch
nnoremap <CR> :nohlsearch<CR>
colorscheme solarized
filetype plugin indent on

" keep the status line up
set laststatus=2

" Let me switch buffers without saving
set hidden

" Undo
set undodir=$HOME/.vim/undo
set undofile
set undolevels=1000
set undoreload=10000

" longer history
set history=200

" Project Specific .vimrc
set exrc
set secure

" Indentation
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
set autoindent

" Annoyance
nnoremap Q <nop>
nnoremap <up> gk
nnoremap <down> gj

" Line numbers
set number
if v:version >= 704
  set relativenumber
  nnoremap <C-n> :set rnu!<CR>
end
" wrap lines on words
set linebreak

" Start scrolling 3 lines before border
set scrolloff=3

" Reread files that have been changed externally
set autoread

" Make ex-mode tab completion work like zsh
set wildmenu
set wildmode=full

function! TrimWhiteSpace()
  let l = line(".")
  let c = col(".")
  %s/\s\+$//e
  call cursor(l, c)
endfunction

function! Cleanup()
  let save_cursor = getpos(".")
  let old_query   = getreg('/')

  :retab
  :normal gg=G
  :%s/\s\+$//e
  :%s/\n\{3,}/\r\r/e

  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfunction
noremap <leader>cu :silent call Cleanup()<CR>

nnoremap <leader>ws :silent call TrimWhiteSpace()<CR>

if !has('win32') && match(system('uname'), 'Darwin') == 0
  nmap <silent> <Leader>d <Plug>DashSearch
  nmap <silent> <Leader>dg <Plug>DashGlobalSearch

  if has('autocmd')
    autocmd FileType markdown,mkd nnoremap <Leader>P :silent !open -a Marked.app '%:p'<CR><C-l>
  endif
endif

cmap w!! %!sudo tee > /dev/null %

if has('autocmd')
  autocmd FileType ruby,javascript,haml,erb,elixir autocmd BufWritePre <buffer> :call TrimWhiteSpace()
  autocmd FileType markdown,mkd set spell
  autocmd FileType markdown,mkd set formatprg=par
endif

" Indent all the html tags
let g:html_indent_inctags = "body,head,tbody,p"

" TAGBAR CONFIG
let g:tagbar_type_elixir = {
      \ 'ctagstype' : 'elixir',
      \ 'kinds' : [
      \ 'f:functions (public)',
      \ 'g:functions (private)',
      \ 'c:callbacks',
      \ 'd:delegates',
      \ 'e:exceptions',
      \ 'i:implementations',
      \ 'a:macros',
      \ 'o:operators',
      \ 'm:modules',
      \ 'p:protocols',
      \ 'r:records',
      \ 't:types',
      \ 'z:foo'
      \ ]
      \ }
" END TAGBAR CONFIG

" Syntastic config
let syntastic_mode_map = { 'passive_filetypes': ['html', 'cucumber'] }
" END Syntastic config

" Only show quick-scope highlights after f/F/t/T is pressed
function! Quick_scope_selective(movement)
  let needs_disabling = 0
  if !g:qs_enable
    QuickScopeToggle
    redraw
    let needs_disabling = 1
  endif

  let letter = nr2char(getchar())

  if needs_disabling
    QuickScopeToggle
  endif

  return a:movement . letter
endfunction

let g:qs_enable = 0

for i in  [ 'f', 'F', 't', 'T' ]
  execute 'noremap <expr> <silent>' .  i . " Quick_scope_selective('".  i . "')"
endfor
